---
title: "Posit Conf 2024: Intro to Shiny for Python"
date: "Aug 12, 2024"
---

## Resources

-   [Overall Shiny Express Website with Slides](https://posit-conf-2024.github.io/intro-to-shiny-for-python/)

-   [Part 1 Slides](https://posit-conf-2024.github.io/intro-to-shiny-for-python/docs/shiny-express-slides.html#/to-make-an-app-reactive-1)

-   [Part 2 Slides](https://posit-conf-2024.github.io/intro-to-shiny-for-python/docs/reactivity-intro-slides.html#/title-slide)

-   [API Ref](https://shiny.posit.co/py/api/express/)

-   [Shiny Express Components](https://shiny.posit.co/py/components/)

-   [Non-Blocking Operations](https://shiny.posit.co/py/docs/nonblocking.html)

    -   this is helpful if you have multiple users

## Basic components

1.  Inputs
2.  Outputs
3.  Instructions for how to build outputs from inputs

*Note: you can use some outputs as inputs and and some inputs as outputs*

## What we don't need to worry about

-   cache

-   state

-   callbacks

-   or even HTML, CSS, or JavaScript

## `Shiny Express` vs `Shiny Core`

-   two different syntaxes for writing shiny apps

-   we will learn `shinyexpress` today

    -   lighter weight

    -   designed around notebooks

    -   apps are faster with less boilerplate

-   You may never need `shiny core`

-   decorators in python allow us to reduce the number of lines of code to do the same thing

    -   `shiny express` uses decorators in a more extensive way; very powerful; less boilerplate

## Discussing Outputs

-   decorators help a lot

-   what is a decorator

    -   a function that wraps another function

    -   returns a modified version of the function being called

    -   allows our code to be much more concise

## Positron notes

-   Press F1 context instead of help

## General python notes

### Fstring

```         
-   fstring basically works like glue() in R
-   "f" stands for "format" string
```

```{python, eval = False}
from shiny.express import input, render, ui

ui.input_slider("n", "N", 0, 100, 20)
@render.text
def txt():
    return f"2 * n is {input.n() * 2}" # fstring basically works like glue() in R
```

## Working on apps/200-penguins

-   App has 2 inputs and 2 outputs

-   check out non-blocking operations on the shiny for python website (in resources above)

## General notes on Python vs R for Shiny

-   For R

    -   Use `bslib` package plus `Rshiny` to get to where we are at now with Python

    -   Tables

        -   use `gt()`

-   For Python

    -   Tables

        -   great tables package

        -   there may be a reactable package ?

## Discussing UI

-   when using `col_widths()` and `row_heights()` , specify the proportion out of 12 that you would like your element to expand to fill.

### Shiny example: layer cards within cards

```{python, eval = False}
#| eval: false

from shiny.express import ui

ui.page_opts(fillable=True)

with ui.layout_columns():  
    with ui.card():  
        ui.card_header("Card 1 header")
        ui.p("Card 1 body")
        ui.input_slider("slider", "Slider", 0, 10, 5)
        
        with ui.card():  
            ui.card_header("SubCard 1 header")
            ui.p("SubCard 1 body")
            ui.input_text("text", "Add text", "")
        
        with ui.card():  
            ui.card_header("SubCard 2 header")
            ui.p("SubCard 2 body")
            ui.input_text("text2", "Add text", "")
```

### Themes

-   Use package `Shinyswatch`

```{python, eval = False}
from shinyswatch import theme 

ui.page_opts(
    title="Model scoring dashboard",
    theme = theme.cerulean
)
```

-   to implement an iframe into your shiny app:

    -   use `tags.iframe()`

## Refactor shiny apps

-   Tips

    -   Keep **reactive** code *in your shiny app* (code that has inputs & outputs) and **non-reactive** code *somewhere else*