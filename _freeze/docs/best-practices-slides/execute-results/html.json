{
  "hash": "fda68aa86d712cacce07a9856dd3a8a0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Workflow best practices\"\ntitle-slide-attributes: \n  data-background-image:  images/shiny-for-python-seattle.jpg\n  data-background-position: bottom left\n  data-background-size: cover\nformat:\n  positconfslides-revealjs: \n    incremental: false\n    chalkboard: true\n    slide-number: c/t\n    code-copy: true\n    center-title-slide: false\n    code-link: true\n    highlight-style: a11y\n    width: \"1600\"\n    height: \"900\"\n    css: \"styles.css\"\n    filters:\n      - positconfslides\n      - reveal-auto-agenda\n    auto-agenda:\n      heading: Agenda\n---\n\n\n\n# Introduction\n\n## Goals\n\n- Learn some Shiny best practices\n- Get a sense of how large complicated apps are structured\n- Know when you need to refactor your application\n\n# Refactoring\n\n## Avoid premature refactoring\n\n- Start by just getting your app to work\n- Take small steps to avoid repetition\n- Ultimately you're the one who needs to work with the code\n\n## When should you refactor?\n- You're trying to hold too much in your head\n- Changing the app is difficult\n- Other people don't understand your code\n- You don't understand your code!\n\n## Three main techniques\n- Use functions to generate UI\n- Separate reactive and non-reactive code\n- Modules\n\n## We're only going to cover two\n::: {.nonincremental}\n- Use functions to generate UI\n- Separate reactive and non-reactive code\n- ~~Modules~~\n:::\n\n# UI Functions\n\n## Background on functions\n\n- In Python, functions are the best way to improve code quality\n    - Don't Repeat Yourself (DRY) principle\n    - Can define variables within the function scope\n    - Can write tests against them\n    - Easy to use in list comprehensions\n- If your code is getting crazy, start refactoring into functions\n\n## Data Science blind spot\n<br><br>\n\n:::{.large}\nData scientists forget funcitons when writing Shiny UIs\n:::\n\n## UI elements are just values\n\n- Recall that Shiny UI elements are just values\n    - They can be saved as variables\n    - They can be stored in lists\n    - They can be passed into functions \n    - They can be returned by functions\n\n## Using functions\n\n```{.python}\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fluid(\n    ui.input_slider(\"n1\", \"N\", 0, 100, 20),\n    ui.input_slider(\"n2\", \"N\", 0, 100, 20),\n    ui.input_slider(\"n3\", \"N\", 0, 100, 20),\n    ui.input_slider(\"n4\", \"N\", 0, 100, 20),\n    ui.input_slider(\"n5\", \"N\", 0, 100, 20),\n    ui.input_slider(\"n6\", \"N\", 0, 100, 20),\n)\n\napp = App(app_ui, None)\n```\n\n## Using functions\n\n```{.python}\nfrom shiny import App, render, ui\n\ndef my_slider(id, label):\n    return ui.input_slider(id, \"N\", 0, 100, 20)\n\napp_ui = ui.page_fluid(\n    my_slider(\"n1\"),\n    my_slider(\"n2\"),\n    my_slider(\"n3\"),\n    my_slider(\"n4\"),\n    my_slider(\"n5\"),\n)\n\napp = App(app_ui, None)\n```\n\n## Applying a function over a list\n\n```{.python}\nfrom shiny import App, render, ui\n\ndef my_slider(id):\n    return ui.input_slider(id, \"N\", 0, 100, 20)\n\nids = [\"n1\", \"n2\", \"n3\", \"n4\", \"n5\"]\n\napp_ui = ui.page_fluid(\n    [my_slider(x) for x in ids]\n)\n\napp = App(app_ui, None)\n```\n\n## Iterating across two lists\n\n```{.python}\nfrom shiny import App, render, ui\n\ndef my_slider(id, label):\n    return ui.input_slider(id, label + \"Number\", 0, 100, 20)\n\nnumbers = [\"n1\", \"n2\", \"n3\", \"n4\", \"n5\", \"n6\"]\nlabels = [\"First\", \"Second\", \"Third\", \"Fourth\", \"Fifth\", \"Sixth\"]\n\napp_ui = ui.page_fluid(\n    [my_slider(x, y) for x, y in zip(numbers, labels)]\n)\n\napp = App(app_ui, None)\n```\n<!-- \n## Benefits of functions\n- Defines the the logic in one place\n- First step on the abstraction ladder\n- Clarifies how components interact with each other\n -->\n\n## Your turn\n\n\n{{< yourturn 'express-modules' >}}\n\n\n## Your turn\n\n\n{{< yourturn 'express-402-iterators' >}}\n\n\n\n## Separate Reactive and Non-reactive logic\n\n- Most Shiny app code is non-reactive\n    - Drawing plots\n    - Summarizing data\n    - Interacting with databases\n    - (Really, everything except the actual reading of reactive inputs and calcs)\n- It's fine to include this code inside reactive functions\n- As your app grows you should separate them\n\n## Reactivity makes everything harder\n\n- Reactive context makes them inherently more difficult\n    - Harder to debug\n    - Harder to test\n    - Harder to document\n    - Harder to reason about\n\n## Pull logic out of the reactive context\n- Non-reactive functions are familliar and predictable\n- You can call them in a notebook\n- You can write unit tests \n- Makes your reactive code much clearer\n- You can reuse them in other contexts\n\n## Your turn\n\n\n{{< yourturn 'express-403-extract-function' >}}\n\n\n\n\n# Modules\n\n## Modules\n\n- Not going to teach them, but you should know about them\n- Used when you want to encapsulate _both_ UI _and_ server logic together\n- Allows you to package and re-use parts of your application\n- Great for working with teams of developers\n- Essential for large applications\n\n# Question and Answer\n\n## Any questions?\n\n# Conclusion\n\n## Thank you!\n\nAlso, please fill out the survey:  \n[https://pos.it/conf-workshop-survey](https://pos.it/conf-workshop-survey)\n\n",
    "supporting": [
      "best-practices-slides_files"
    ],
    "filters": [],
    "includes": {}
  }
}