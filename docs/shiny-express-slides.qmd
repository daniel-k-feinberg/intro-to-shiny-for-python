---
title: "Getting started with Shiny express"
title-slide-attributes: 
  data-background-image:  images/shiny-for-python-seattle.jpg
  data-background-position: bottom left
  data-background-size: cover
format:
  positconfslides-revealjs:
    incremental: false
    chalkboard: true
    slide-number: c/t
    code-copy: true
    center-title-slide: false
    code-link: true
    highlight-style: a11y
    width: "1600"
    height: "900"
    css: "styles.css"
    filters:
      - positconfslides
      - reveal-auto-agenda
    auto-agenda:
      heading: Agenda
---

```{python}
# | echo: false
import os
import sys
exercises_path = "./exercises"
if exercises_path not in sys.path:
    sys.path.append(exercises_path)

from helpers import include_shiny_folder
```

# Getting started


## Goals of Session 1

1.  Understand the mechanics of a Shiny app (what to do, not why you do it)

2.  Develop comfort with failure and debugging

3.  You know where to go for help

## Why Shiny?

Introduce the end state / whole game / bigger picture: web page with a server. 

The server watches the web page and responds to user events on that page.

We need to tell the compute what to do when the user clicks.


## How this session works

-   This session is going to be exercise based
-   All of the exercises and slides are running live on the [website](https://posit-conf-2024.github.io/intro-to-shiny-for-python/)
-   You can do them on the website or open the apps in the `apps/core` folder
-   If you need help, put a red sticker on your laptop; when you're done, put up a green sticker

## Your turn

{{< yourturn 'express-101-hello-world' >}}


# Hello Shiny

## What is a Shiny app?

```{python}
# | echo: false
# | output: asis

include_shiny_folder(
    "apps/000-penguins", components="viewer", viewer_height=700
)
```

## Key features of Shiny

-   Easy to develop
-   Extensible
-   Efficient

## Why Shiny for Python?

Shiny is great because it lets you quickly create web apps without worrying about maintaining cache, managing state, and callbacks â€” or even HTML, CSS, and JavaScript.

-   Shiny is designed to take you from prototype to production
-   Easy enough to use for prototypes
-   Efficient enough to handle complexity
-   Everything you need to build production quality apps
-   You don't need to throw away your Shiny apps

# Anatomy of a Shiny App

## You need three things

To make a Shiny app work you need to do three things:

1.  Create a **UI section** that describes inputs and outputs

    - Can contain text, plots, buttons, sliders, etc.

2. Create a **server section**

    - Contains your application logic
    - In particular, it contains **rendering functions** that turn inputs into outputs

3.  Link the server section and UI section

    - by referring to the inputs in the server section


## Inputs using shiny express

```{.python filename="app.py" code-line-numbers="3-4"}
from shiny.express import input, render, ui

# UI section
ui.input_slider(id = "n", label = "N", min = 0, max = 100, value = 20)

## Server section
@render.text
def txt():
    return f"2 * n is {input.n() * 2}"
```

<br />


```{shinylive-python}
#| standalone: true
#| viewerHeight: 150

from shiny.express import input, render, ui

# UI section
ui.input_slider("n", "N", 0, 100, 20)

## Server section
@render.text
def txt():
    return f"2 * n is {input.n() * 2}"
```

## Server section using shiny express

``` {.python filename="app.py" code-line-numbers="6-9"}
from shiny.express import input, render, ui

# UI section
ui.input_slider(id = "n", label = "N", min = 0, max = 100, value = 20)

## Server section
@render.text
def txt():
    return f"2 * n is {input.n() * 2}"
```

<br />

```{shinylive-python}
#| standalone: true
#| viewerHeight: 150

from shiny.express import input, render, ui

# UI section
ui.input_slider("n", "N", 0, 100, 20)

## Server section
@render.text
def txt():
    return f"2 * n is {input.n() * 2}"
```

## Refer to inputs

Your render function can refer to the input by calling it like a function.

In this case, the `input_slider` has the name `"n"`, so you refer to it as `input.n()`.


```{.python filename="app.py" code-line-numbers="9"}
from shiny.express import input, render, ui

# UI section
ui.input_slider(id = "n", label = "N", min = 0, max = 100, value = 20)

## Server section
@render.text
def txt():
    return f"2 * n is {input.n() * 2}"
```

<br />

```{shinylive-python}
#| standalone: true
#| viewerHeight: 150

from shiny.express import input, render, ui

# UI section
ui.input_slider("n", "N", 0, 100, 20)

## Server section
@render.text
def txt():
    return f"2 * n is {input.n() * 2}"
```

## UI functions

-   The `ui` submodule contains functions to create UI elements
-   Inputs start with `ui.input_*()` and take an `id` and options
-   Other functions like `ui.h1()` or `ui.p()` add static HTML to the app
-   We'll get to layout functions in Session 3

<https://shiny.posit.co/py/api/express/express.ui.input_select.html>

## Inputs component gallery

![](images/input-component-gallery.png)

<https://shiny.posit.co/py/components/>


## Render functions for outputs

The render functions define the outputs of the app.

-   Outputs start with `render_*()` and usually just take an id

<https://shiny.posit.co/py/api/express/express.render.plot.html>


## Outputs component gallery

![](images/output-component-gallery.png)

<https://shiny.posit.co/py/components/>


## Your turn

{{< yourturn 'express-102-data-frame' >}}


# Rendering functions on the server side

## Server function

-   Every Shiny app needs a `server` function
-   The server function executes for each user session
-   This function contains **rendering functions** which define how to turn inputs into outputs

## Rendering functions

``` python
def server(input, output, session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"
```

-   Functions are defined inside the main `server` function
-   They need to be **decorated** with `@output` and `@render.*` in that order
-   The function **name** should match the output id
-   The return value is sent to the Shiny UI

## Decorators are just functions

``` python
    @output
    @render.plot(alt="A body mass plot of penguins")
    def mass_plot():
        df = sample_data(penguins.copy(), input.sample())
        df = df.loc[df["body_mass"] < input.mass()]
        return dist_plot(df)
```

-   Decorators are functions which take other functions
-   Shiny uses them to identify reactive functions
-   They can take arguments

## Simple app example

``` {.python code-line-numbers="5,10-13"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)

def server(input, output, session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"

app = App(app_ui, server)
```

## Common problems

-   An output doesn't render
-   An output doesn't update when an input changes
-   There's some weird error

## Your turn

{{< yourturn 'express-103-debug' >}}


# Making the link

## Connecting inputs to outputs

``` {.python code-line-numbers="5"}
def server(input: Inputs, output: Outputs, session: Session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"
```

-   Inputs are read by calling them like a function: `input.n()`, not `input.n`
-   Referring to an input creates a reactive link between that input and the rendering function
-   When the input changes, the rendering function will re-execute
-   You can use multiple inputs in the same rendering function

## Your turn

{{< yourturn 'express-104-filter' >}}


## Your turn

{{< yourturn 'express-105-connect-filter' >}}


## Your turn

{{< yourturn 'express-106-debug' >}}


## Your turn

{{< yourturn 'express-107-debug' >}}


# Recap

## Summary

Most Shiny app development consists of variations of these three things:

1.  Add UI elements
2.  Add rendering functions
3.  Connect inputs and outputs

## Your turn

{{< yourturn 'express-108-plot' >}}

