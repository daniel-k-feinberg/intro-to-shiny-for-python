---
title: "Intro to Shiny Modules"
title-slide-attributes: 
  data-background-image:  images/shiny-for-python-seattle.jpg
  data-background-position: bottom left
  data-background-size: cover
format:
  positconfslides-revealjs: 
    incremental: false
    chalkboard: true
    slide-number: c/t
    code-copy: true
    center-title-slide: false
    code-link: true
    highlight-style: a11y
    width: "1600"
    height: "900"
    css: "styles.css"
    filters:
      - positconfslides
      - reveal-auto-agenda
    auto-agenda:
      heading: Agenda
---



# Modules

## Modules

A `shiny` module provides you with a way to encapsulate both:

- UI logic
- Render logic

This allows you to:

1. Create re-usable components
2. Abstract large parts of code into a separate unit


This is:

- Great for working with teams of developers
- Essential for large applications

## Module example

Create a shiny module:

 ```{.python}
from shiny.express import ui, render

from shiny express import input, output, session, module

@module
def card_module(input, output, session, title, fn):
    with ui.card():
        ui.card_header(title)
        @render.plot
        def _plot_out():
            return fn()
```

Call the module like you call a function:

```{.python}
card_module('id', 'title', fn)
```

## Look carefully at the definition and the call:

Create a shiny module:

 ```{.python}
@module
def card_module(input, output, session, title, fn):
    ...
```


\

Call the module like you call a function:

```{.python}
card_module('id1', 'title', fn)

```

\

::: {.callout-important}
Notice that:

1. You don't pass `input`, `output` or `session` to the module
2. You pass an `id` that must be unique in the namespace
3. And then you pass the other arguments
:::


## Your turn

{{< yourturn 'express-402-modules' >}}

